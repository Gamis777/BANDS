# -*- coding: utf-8 -*-
"""EXAMEN_FINAL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17R5497JuQeW_r9XHvfAuW4FsvEHerNPw

**EXPLORATORY DATA**
"""

#Ingreso de librerias
import pandas as pd
import numpy as np

# header: el número de fila para usar como nombre de columnas
# names: lista de los nombres de las columnas
data=pd.read_csv('bands.csv',header=0)

#agregamos cabeceras
columna=np.array(['marca de tiempo','número de cilindro','cliente','número de trabajo','grano tamizado','color de tinta','prueba en tinta ctd','blade mfg','división del cilindro','tipo de papel','tipo de tinta','vapor directo','tipo de disolvente','tipo en cilindro','tipo de prensa','prensa','número de unidad','tamaño del cilindro','ubicación de la fábrica de papel','tanque de recubrimiento','corte de prueba','viscosidad','calibre','temperatura de la tinta','humedad','rugosidad','presión de la cuchilla','PCT barniz','velocidad de la prensa','PCT de tinta','PCT solvente','Voltaje ESA','Amperaje ESA','cera','endurecedor','durómetro de rodillo','densidad de corriente','relación de espacio anódico','contenido de cromo','tipo de banda'])

data.columns=columna

#imprime los elementos desde la parte de arriba
data.head(5)

#imprime los elementos  desde  la parte de  abajo
data.tail(2)

data.shape

#imprime las cabeceras con los tipos de datos que almacenan
data.dtypes

#Cantidad de registros por columna
data.count()

#Cantidad de registros considerando nulos
len(data)

# Cantidad de nulos en cada columna
data.isnull().sum()

# include='all' ó include=['object']: incluye las columnas tipo texto
#describe las base de datos con su valores estadisticos se incluye all para tipo string
data.describe(include = "all")

# Indica TRUE si tiene valores nulos, indica FALSE si no tiene ningún valor nulo
data.isnull().any()

"""Tipo de  dato"""

#Cantidad de valores de cada tipo único, el resultado es una Serie 
data['número de trabajo'].value_counts()

#Cantidad de valores de cada tipo único, el resultado es un Dataframe 
#retorna como resultado un data frame la cantidad de veces que se repite un valor
data['humedad'].value_counts().to_frame()

data.loc[420]

#seleccionamos  una cantidad de datos de una columna tipo de  papel
data.loc[420:430,'tipo de papel']

#seleccionamos  una cantidad de datos de una columna
data.loc[420:430,'tipo de papel']

"""**CLEANING DATA**

REPLACE
"""

# Reemplazar los valores faltantes ('?') con valores nulos
#remplaza un valor por otro
data['tamaño del cilindro'].replace(' ?', np.nan, inplace = True)
data['tanque de recubrimiento'].replace(' ?', np.nan, inplace = True)
data['ubicación de la fábrica de papel'].replace(' ?', np.nan, inplace = True)
data['corte de prueba'].replace('?',np.nan, inplace = True)
data['viscosidad'].replace(' ?', np.nan, inplace = True)
data['calibre'].replace(' ?', np.nan, inplace = True)
data['temperatura de la tinta'].replace(' ?', np.nan, inplace = True)
data['humedad'].replace(' ?', np.nan, inplace = True)
data['rugosidad'].replace(' ?', np.nan, inplace = True)
data['presión de la cuchilla'].replace(' ?', np.nan, inplace = True)
data['PCT barniz'].replace(' ?', np.nan, inplace = True)
data['velocidad de la prensa'].replace(' ?', np.nan, inplace = True)
data['PCT de tinta'].replace(' ?', np.nan, inplace = True)
data['PCT solvente'].replace(' ?', np.nan, inplace = True)
data['Voltaje ESA'].replace(' ?', np.nan, inplace = True)
data['Amperaje ESA'].replace(' ?', np.nan, inplace = True)
data['cera'].replace(' ?', np.nan, inplace = True)
data['endurecedor'].replace(' ?', np.nan, inplace = True)
data['durómetro de rodillo'].replace(' ?', np.nan, inplace = True)
data['densidad de corriente'].replace(' ?', np.nan, inplace = True)
data['relación de espacio anódico'].replace(' ?', np.nan, inplace = True)
data['contenido de cromo'].replace(' ?', np.nan, inplace = True)
data['tipo de banda'].replace(' ?', np.nan, inplace = True)

data['tamaño del cilindro'].isnull().sum()

data['tanque de recubrimiento'].isnull().sum()

data['ubicación de la fábrica de papel'].isnull().sum()

data['corte de prueba'].isnull().sum()

data['viscosidad'].isnull().sum()

data['calibre'].isnull().sum()

data['temperatura de la tinta'].isnull().sum()

data['humedad'].isnull().sum()

data['rugosidad'].isnull().sum()

data['presión de la cuchilla'].isnull().sum()

data['velocidad de la prensa'].isnull().sum()

data['PCT de tinta'].isnull().sum()

d1=data['ubicación de la fábrica de papel']

# Comprueba la Cantidad de nulos en cada columna
data.isnull().any()

#retorna como resultado un data frame la cantidad de veces que se repite un valor
data['humedad'].value_counts().to_frame()

"""**CLEANING DATA**

Eliminar Columnas
"""

#accedes por fila y columna a un valor o valores deseados
data.loc[1:10,'calibre']

to_drop= ['vapor directo']#elimina la columna

data.drop(to_drop, inplace=True, axis=1)

data.columns #imprime  las cabeceras

#how='all', elimina columnas que tengan todos sus valores nulos
#how='any', elimina columnas que tengan al menos un valor nulo
#data.dropna(axis=1, how='any', inplace = True)#elimina los nulos

data.isnull().sum()

# Indica TRUE si tiene valores nulos, indica FALSE si no tiene ningún valor nulo
#ahora  ya no tiene  nulos  porque  elinamos  las  columnas  con   nulos
data.isnull().any()

data.reset_index(drop=True, inplace=True)#resetea y modifica el tamaño de las tablas

data.shape

d1=data['blade mfg']

d1 = d1.str.replace('BENTON','B')#remplaza

d1

#d1 = d1.str.contains('0')# muestra los valores que contengan dicho caracter

#EXTRACT
d1=data['cliente']
d1=np.where (d1=='KMART')#guardamos solo las posiciones  en las que aparece el cliente KMART
d1

"""**DATA wrangling**

Es el proceso de limpiar, estructurar y enriquecer los datos que están en bruto, para obtenerlos un formato que permita una mejor toma de decisiones en menos tiempo.
"""

data.head()

from google.colab import files 
uploaded = files.upload()#carga archivos desde codigo

data.dtypes

data['relación de espacio anódico'].value_counts()

#remplazamos  los datos  faltantes por  nulos 
# hallamos la  media de  la columna
serie=data['relación de espacio anódico']
serie=pd.to_numeric(serie,errors='coerce')
serie.fillna(0)
serie.agg({"relación de espacio anódico": "mean"})

#convierto a float  la columna relación de espacio anódico
serie=data['relación de espacio anódico']
serie=pd.to_numeric(serie,errors='coerce')
serie.fillna(0)

#convierto a float  la columna rugosidad
serie=data['rugosidad']
serie=pd.to_numeric(serie,errors='coerce')
serie.fillna(0)

"""**Normalización de datos**

Escalar la variable para que los valores de la variable varíen de 0 a 1.

Ejemplo: Reemplazar el valor original de la siguiente manera:

(valor original) / (valor máximo)
"""

data.shape

#normalizamos la columna número de unidad
data['número de unidad'] = data['número de unidad']/data['número de unidad'].max()

data['número de unidad']

"""Binning"""

data ['viscosidad'].replace('?', np.nan, inplace=True)
data['viscosidad'] = data['viscosidad'].astype('float')
media = data['viscosidad'].mean()
data['viscosidad'].replace( np.nan, media, inplace=True)

data['viscosidad']

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib as plt
from matplotlib import pyplot

plt.pyplot.hist(data["viscosidad"])

# set x/y labels and plot title
plt.pyplot.xlabel("viscosidad")
plt.pyplot.ylabel("count")
plt.pyplot.title("viscosidad de las tintas")

data ['temperatura de la tinta'].replace('?', np.nan, inplace=True)
data['temperatura de la tinta'] = data['temperatura de la tinta'].astype('float')
media = data['temperatura de la tinta'].mean()
data['temperatura de la tinta'].replace( np.nan, media, inplace=True)
data['temperatura de la tinta']

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib as plt
from matplotlib import pyplot
plt.pyplot.hist(data['temperatura de la tinta'])
# set x/y labels and plot title
plt.pyplot.xlabel('temperatura de la tinta')
plt.pyplot.ylabel("count")
plt.pyplot.title('temperaturas ')

#vemos  en formato de histograma  el grado de  concetracion de  los datos en ciertos  intervalos 
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize']=[15.,15.]
data.drop([],1).hist()
plt.show()

datax=data['tipo de banda'].unique()
datax

datay=data['tipo de banda'].value_counts()
datay

"""**Variable de  Predicción:**El último atributo, band o noband

**Variables indicador**
"""

data.head(2)

data['tipo de banda'].value_counts()

dummy_variable_1 = pd.get_dummies(data['tipo de banda'])

dummy_variable_1.head()

type(dummy_variable_1)

data = pd.concat([data, dummy_variable_1], axis=1)

data.head(2)

data.drop('tipo de banda', axis = 1, inplace=True)

"""**Regresión Lineal y Logística**"""

#los atributos que presenten mayor correlación con el atributo de predicción.

data.corr()

# Con valores en las celdas, los colores de oscuro(-1,1;buena corr) a claro(0, mala corr) se ajustan por columna
corr=data.corr()
corr.style.background_gradient(cmap='coolwarm', axis=None).set_precision(4)

# Sin valores en las celdas
corr.style.background_gradient(cmap='coolwarm').set_properties(**{'font-size': '0pt'})

"""**Correlación entre variables**"""

data[["viscosidad", "temperatura de la tinta"]].corr()

#la correlacion  entre la viscosidad y la temperatura de la tinta es 	-0.0555
import sklearn
from scipy import stats
import matplotlib.pyplot as plt
import os
import seaborn as sns
sns.regplot(x="viscosidad", y="temperatura de la tinta", data=data)
plt.ylim(0)

#vemos la relacion que hay  la variable viscosidad  con  dos variables
import sklearn
from scipy import stats
import matplotlib.pyplot as plt
import os
import seaborn as sns
sns.pairplot(data.dropna(),hue='viscosidad',size=6,vars=['temperatura de la tinta','número de unidad'],kind='reg')
plt.show()

#Función describe() para las variables de tipo Object
data.describe(include=['object'])

"""**Scikit - Learn**"""

from sklearn import linear_model
from sklearn import model_selection
from sklearn.metrics import accuracy_score

X = np.array(data['viscosidad'])
y = np.array(data['temperatura de la tinta'])
X.shape

validation_size = 0.20
seed = 7
x_train, x_test, y_train, y_test = model_selection.train_test_split(X, y, test_size=validation_size, random_state=seed)

x_train.shape

"""**Regresión Lineal**

Training
"""

#X tiene 2 dimensiones, donde como, su x_trainy x_test tiene una  agregamos:x_train = x_train.reshape(-1, 1)
x_test = x_test.reshape(-1, 1)
x_train = x_train.reshape(-1, 1)
x_test = x_test.reshape(-1, 1)
model1 = linear_model.LinearRegression()
model1.fit(x_train,y_train)

"""Predicción con la data de Test"""

z_pred = model1.predict(x_test)

# Porcentaje de precisión alcanzada
model1.score(x_test, y_test)

"""**Regresión Logística**"""

from sklearn import linear_model
from sklearn import model_selection
from sklearn.metrics import accuracy_score
X = data.iloc[:, [22, 24]].values
y = data.iloc[:, 40].values
validation_size = 0.20
seed = 7
x_train, x_test, y_train, y_test = model_selection.train_test_split(X, y, test_size=validation_size, random_state=seed)
model = linear_model.LogisticRegression(max_iter=1000, multi_class='auto')
model.fit(x_train,y_train)
